Example 1: 
Given a string s, return true if it is a palindrome, false otherwise.

A string is a palindrome if it reads the same forward as backward. That means, after reversing it, it is still the same string. For example: "abcdcba", or "racecar".

Hint:
To start, we check the first and last characters using two separate pointers.
To check the next pair of characters, we just need to move our pointers toward each other one position.
We continue until 
a. The pointers meet each other (or)
b. We find a mismatch.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Example 2:
Given a sorted array of unique integers and a target integer, return true if there exists a pair of numbers that sum to target, false otherwise.
This problem is similar to Two Sum. (In Two Sum, the input is not sorted).

For example, given nums = [1, 2, 4, 6, 8, 9, 14, 15] and target = 13, return true because 4 + 9 = 13.

Hint:
-----
Because the array is sorted, we can use two pointers to improve to an O(n) time complexity.

Example:
--------
Let's say we have nums = [3, 6, 21, 23, 25] and target = 27. We need to pick two numbers that sum to target. 

Using the two pointers technique, we start with the first and last numbers. 
Because the input is sorted, this is the smallest and largest number. 

We have 3 + 25 = 28, which is greater than target.

Let's look at the 25. We paired this number with the smallest number, and the sum was still too large. 
That implies that the 25 could never be part of the answer, because if we chose any number other than the 3 to 
pair it with, the sum would be even larger. 

Since it can't be part of the answer, we move on to the next largest number, which is 23.

Now, we have 3 + 23 = 26. This is smaller than target. In the previous step, we determined that the 25 could never 
be part of the answer. 

This makes the 23 the new "largest" number. Despite pairing the 3 with the largest number, the sum is still too small. 

This implies that the 3 could never be part of the answer, because if we chose any of the other remaining numbers
 (the 6 or 21), the sum would be even smaller. 
 
Since it can't be part of the answer, we move on to the next smallest number, which is 6.

Now, we have 6 + 23 = 29. Once again, our sum is too large. 
We apply the same logic as before - the 23 could never be part of the answer because we are already 
pairing it with the smallest number (that we haven't already ruled out), yet the sum is still too large. 

So we move to the next largest number, which is the 21.

Finally, we have 6 + 21 = 27, and we have found our target.

Algorithm:
----------

To implement this algorithm, we use a similar process as in the previous palindrome example.

We use a while loop until the pointers meet each other. If at any point the sum is equal to the target, 
we can return true. 

If the pointers meet each other, it means we went through the entire input without finding target, so we return false.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
